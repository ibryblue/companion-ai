<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VRM Animation Test</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f0f0f0;
      color: #333;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }
    
    h1 {
      text-align: center;
      margin-bottom: 20px;
    }
    
    .viewer-container {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
    }
    
    .vrm-viewer {
      flex: 1;
      min-width: 300px;
      height: 500px;
      background-color: #222;
      border-radius: 8px;
      overflow: hidden;
      position: relative;
    }
    
    .controls-container {
      flex: 1;
      min-width: 300px;
      background-color: #fff;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
    
    .status-container {
      margin-top: 20px;
      padding: 10px;
      background-color: #eee;
      border-radius: 4px;
    }
    
    .error-container {
      margin-top: 10px;
      padding: 10px;
      background-color: #ffebee;
      color: #c62828;
      border-radius: 4px;
      display: none;
    }
    
    .success {
      color: #2e7d32;
    }
    
    .error {
      color: #c62828;
    }
    
    .warning {
      color: #f57f17;
    }
    
    .info {
      color: #1565c0;
    }
    
    button {
      background-color: #4CAF50;
      color: white;
      border: none;
      padding: 10px 15px;
      margin: 5px 0;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    
    button:hover {
      background-color: #45a049;
    }
    
    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    
    .button-group {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }
    
    .file-input-container {
      margin-bottom: 15px;
    }
    
    .file-input-container label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }
    
    .drop-zone {
      border: 2px dashed #ccc;
      border-radius: 5px;
      padding: 25px;
      text-align: center;
      margin: 15px 0;
      background-color: #f9f9f9;
      cursor: pointer;
      transition: all 0.3s;
    }
    
    .drop-zone:hover {
      background-color: #f0f0f0;
      border-color: #aaa;
    }
    
    .animation-list {
      margin-top: 15px;
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #eee;
      border-radius: 4px;
      padding: 10px;
    }
    
    .animation-item {
      padding: 5px;
      border-bottom: 1px solid #eee;
      cursor: pointer;
    }
    
    .animation-item:hover {
      background-color: #f5f5f5;
    }
    
    .animation-item.active {
      background-color: #e3f2fd;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>VRM Animation Test</h1>
    
    <div class="viewer-container">
      <div id="vrm-viewer" class="vrm-viewer"></div>
      
      <div class="controls-container">
        <h2>Controls</h2>
        
        <div class="button-group">
          <button id="load-sample-vrm">Load Sample VRM</button>
          <button id="load-custom-vrm">Load Custom VRM</button>
          <input type="file" id="vrm-file-input" accept=".vrm" style="display: none;">
        </div>
        
        <div id="animation-controls">
          <h3>Animation Controls</h3>
          
          <div class="file-input-container">
            <label for="animation-file-input">Load Animation:</label>
            <input type="file" id="animation-file-input" accept=".vrma,.fbx,.bvh,.gltf,.glb" disabled>
          </div>
          
          <div id="animation-drop-zone" class="drop-zone">
            Drag & Drop Animation File Here
          </div>
          
          <div class="button-group">
            <button id="play-animation" disabled>Play</button>
            <button id="stop-animation" disabled>Stop</button>
            <button id="reset-animation" disabled>Reset</button>
            <button id="test-animation">Create Test Animation</button>
          </div>
          
          <div id="animation-list" class="animation-list">
            <div class="animation-item">No animations loaded</div>
          </div>
        </div>
        
        <div id="status-container" class="status-container">
          Ready to load VRM model
        </div>
        
        <div id="error-container" class="error-container"></div>
      </div>
    </div>
  </div>
  
  <!-- Import Three.js from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.151.3/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.151.3/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.151.3/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.151.3/examples/js/loaders/FBXLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.151.3/examples/js/loaders/BVHLoader.js"></script>
  
  <!-- Import @pixiv/three-vrm from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@1.0.9/lib/three-vrm.min.js"></script>
  
  <!-- Import our local scripts -->
  <script src="js/vrm-animation-handler.js"></script>
  <script src="js/vrm-animation-controls.js"></script>
  
  <script>
    // Main application
    class VRMAnimationApp {
      constructor() {
        // Elements
        this.vrmViewerElement = document.getElementById('vrm-viewer');
        this.statusElement = document.getElementById('status-container');
        this.errorElement = document.getElementById('error-container');
        this.animationListElement = document.getElementById('animation-list');
        
        // Buttons
        this.loadSampleVRMButton = document.getElementById('load-sample-vrm');
        this.loadCustomVRMButton = document.getElementById('load-custom-vrm');
        this.vrmFileInput = document.getElementById('vrm-file-input');
        this.animationFileInput = document.getElementById('animation-file-input');
        this.animationDropZone = document.getElementById('animation-drop-zone');
        this.playAnimationButton = document.getElementById('play-animation');
        this.stopAnimationButton = document.getElementById('stop-animation');
        this.resetAnimationButton = document.getElementById('reset-animation');
        this.testAnimationButton = document.getElementById('test-animation');
        
        // Three.js components
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.controls = null;
        this.clock = null;
        
        // VRM components
        this.currentVRM = null;
        this.animationHandler = null;
        
        // Initialize
        this.init();
      }
      
      init() {
        this.initScene();
        this.initEventListeners();
        this.animate();
        
        this.updateStatus('Scene initialized, ready to load VRM model');
      }
      
      initScene() {
        // Create scene
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x212121);
        
        // Create camera
        this.camera = new THREE.PerspectiveCamera(
          30.0,
          this.vrmViewerElement.clientWidth / this.vrmViewerElement.clientHeight,
          0.1,
          20.0
        );
        this.camera.position.set(0.0, 1.0, 5.0);
        
        // Create renderer
        this.renderer = new THREE.WebGLRenderer({
          antialias: true,
          alpha: true
        });
        this.renderer.setSize(this.vrmViewerElement.clientWidth, this.vrmViewerElement.clientHeight);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        this.vrmViewerElement.appendChild(this.renderer.domElement);
        
        // Create camera controls
        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
        this.controls.target.set(0.0, 1.0, 0.0);
        this.controls.update();
        
        // Add lights
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(1.0, 1.0, 1.0).normalize();
        directionalLight.castShadow = true;
        this.scene.add(directionalLight);
        
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        this.scene.add(ambientLight);
        
        // Add grid helper
        const gridHelper = new THREE.GridHelper(10, 10, 0x555555, 0x333333);
        this.scene.add(gridHelper);
        
        // Create clock
        this.clock = new THREE.Clock();
        this.clock.start();
        
        // Handle window resize
        window.addEventListener('resize', this.onWindowResize.bind(this));
      }
      
      initEventListeners() {
        // Load sample VRM
        this.loadSampleVRMButton.addEventListener('click', () => {
          this.loadSampleVRM();
        });
        
        // Load custom VRM
        this.loadCustomVRMButton.addEventListener('click', () => {
          this.vrmFileInput.click();
        });
        
        // Handle VRM file selection
        this.vrmFileInput.addEventListener('change', (e) => {
          const file = e.target.files[0];
          if (file) {
            this.loadVRMFromFile(file);
          }
        });
        
        // Handle animation file selection
        this.animationFileInput.addEventListener('change', (e) => {
          const file = e.target.files[0];
          if (file) {
            this.loadAnimationFromFile(file);
          }
        });
        
        // Animation drop zone events
        this.animationDropZone.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.stopPropagation();
          
          if (!this.currentVRM) return;
          
          this.animationDropZone.style.backgroundColor = 'rgba(200, 200, 255, 0.2)';
          this.animationDropZone.style.borderColor = '#aaa';
        });
        
        this.animationDropZone.addEventListener('dragleave', (e) => {
          e.preventDefault();
          e.stopPropagation();
          
          this.animationDropZone.style.backgroundColor = '#f9f9f9';
          this.animationDropZone.style.borderColor = '#ccc';
        });
        
        this.animationDropZone.addEventListener('drop', (e) => {
          e.preventDefault();
          e.stopPropagation();
          
          this.animationDropZone.style.backgroundColor = '#f9f9f9';
          this.animationDropZone.style.borderColor = '#ccc';
          
          if (!this.currentVRM) {
            this.updateStatus('Please load a VRM model first', 'error');
            return;
          }
          
          const file = e.dataTransfer.files[0];
          if (file) {
            this.loadAnimationFromFile(file);
          }
        });
        
        // Animation control buttons
        this.playAnimationButton.addEventListener('click', () => {
          if (this.animationHandler && this.animationHandler.currentAction) {
            if (this.animationHandler.currentAction.isRunning() && 
                !this.animationHandler.currentAction.paused) {
              this.animationHandler.currentAction.paused = true;
              this.playAnimationButton.textContent = 'Play';
              this.updateStatus('Animation paused');
            } else {
              this.animationHandler.currentAction.paused = false;
              this.playAnimationButton.textContent = 'Pause';
              this.updateStatus('Animation playing');
            }
          }
        });
        
        this.stopAnimationButton.addEventListener('click', () => {
          if (this.animationHandler) {
            this.animationHandler.stopAnimation();
            this.playAnimationButton.textContent = 'Play';
            this.updateStatus('Animation stopped');
            this.updateAnimationControls();
          }
        });
        
        this.resetAnimationButton.addEventListener('click', () => {
          if (this.animationHandler && this.animationHandler.currentAction) {
            this.animationHandler.currentAction.reset();
            this.updateStatus('Animation reset');
          }
        });
        
        // Click on animation drop zone to trigger file input
        this.animationDropZone.addEventListener('click', () => {
          if (this.currentVRM) {
            this.animationFileInput.click();
          }
        });
        
        // Test animation button
        if (this.testAnimationButton) {
          this.testAnimationButton.addEventListener('click', () => {
            if (!this.currentVRM) {
              this.updateStatus('Please load a VRM model first', 'error');
              return;
            }
            
            if (!this.animationHandler) {
              this.initAnimationHandler();
            }
            
            if (this.animationHandler) {
              this.updateStatus('Creating test animation...', 'info');
              
              // Create a simple test animation
              const testAnimation = this.animationHandler.createSimpleTestAnimation();
              
              if (testAnimation) {
                // Play the test animation
                this.animationHandler.playAnimation(testAnimation);
                this.updateStatus('Test animation created and playing', 'success');
                
                // Update UI
                this.playAnimationButton.textContent = 'Pause';
                this.updateAnimationControls();
                
                // Update animation list
                this.updateAnimationList([testAnimation]);
              } else {
                this.updateStatus('Failed to create test animation', 'error');
              }
            }
          });
        }
      }
      
      animate() {
        requestAnimationFrame(this.animate.bind(this));
        
        const delta = this.clock.getDelta();
        
        // Update VRM
        if (this.currentVRM && this.currentVRM.update) {
          this.currentVRM.update(delta);
        }
        
        // Update animation
        if (this.animationHandler) {
          this.animationHandler.update(delta);
        }
        
        // Update controls
        if (this.controls) {
          this.controls.update();
        }
        
        // Render
        if (this.renderer && this.scene && this.camera) {
          this.renderer.render(this.scene, this.camera);
        }
      }
      
      onWindowResize() {
        if (!this.camera || !this.renderer) return;
        
        this.camera.aspect = this.vrmViewerElement.clientWidth / this.vrmViewerElement.clientHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(this.vrmViewerElement.clientWidth, this.vrmViewerElement.clientHeight);
      }
      
      loadSampleVRM() {
        this.updateStatus('Loading sample VRM model...');
        this.clearError();
        
        // Sample VRM URL from @pixiv/three-vrm examples
        const sampleVRMUrl = 'https://cdn.jsdelivr.net/gh/pixiv/three-vrm@release/packages/three-vrm/examples/models/VRM1_Constraint_Twist_Sample.vrm';
        
        this.loadVRMFromURL(sampleVRMUrl);
      }
      
      loadVRMFromURL(url) {
        // Clear existing model
        if (this.currentVRM && this.currentVRM.scene) {
          this.scene.remove(this.currentVRM.scene);
          this.currentVRM = null;
        }
        
        // Clean up animation handler
        if (this.animationHandler) {
          this.animationHandler.dispose();
          this.animationHandler = null;
        }
        
        this.updateStatus(`Loading VRM from URL: ${url}...`);
        
        // Create loader
        const loader = new THREE.GLTFLoader();
        
        // Register VRM plugin
        loader.register((parser) => {
          return new THREE.VRM.VRMLoaderPlugin(parser);
        });
        
        // Load the model
        loader.load(
          url,
          (gltf) => {
            this.updateStatus('Processing VRM model...');
            
            try {
              // Handle VRM data
              if (gltf.userData && gltf.userData.vrm) {
                this.currentVRM = gltf.userData.vrm;
                this.scene.add(this.currentVRM.scene);
                
                // Initialize animation handler
                this.initAnimationHandler();
                
                this.updateStatus('VRM model loaded successfully!', 'success');
              } else {
                // Fallback to just using the GLTF scene
                this.updateStatus('No VRM data found, using raw GLTF scene', 'warning');
                
                this.currentVRM = {
                  scene: gltf.scene,
                  update: null
                };
                this.scene.add(gltf.scene);
                
                // Initialize animation handler
                this.initAnimationHandler();
              }
              
              // Update UI
              this.updateAnimationControls();
            } catch (error) {
              console.error('Error processing VRM model:', error);
              this.showError(`Error processing VRM model: ${error.message}`);
            }
          },
          (progress) => {
            const percent = progress.total > 0 ? Math.round(progress.loaded / progress.total * 100) : 0;
            this.updateStatus(`Loading model: ${percent}%`);
          },
          (error) => {
            console.error('Error loading VRM model:', error);
            this.showError(`Failed to load VRM model: ${error.message}`);
          }
        );
      }
      
      loadVRMFromFile(file) {
        if (!file) return;
        
        // Clear existing model
        if (this.currentVRM && this.currentVRM.scene) {
          this.scene.remove(this.currentVRM.scene);
          this.currentVRM = null;
        }
        
        // Clean up animation handler
        if (this.animationHandler) {
          this.animationHandler.dispose();
          this.animationHandler = null;
        }
        
        this.updateStatus(`Loading VRM from file: ${file.name}...`);
        this.clearError();
        
        // Create file reader
        const reader = new FileReader();
        
        reader.onload = (e) => {
          // Create loader
          const loader = new THREE.GLTFLoader();
          
          // Register VRM plugin
          loader.register((parser) => {
            return new THREE.VRM.VRMLoaderPlugin(parser);
          });
          
          // Parse the loaded file
          loader.parse(
            e.target.result,
            '',
            (gltf) => {
              this.updateStatus('Processing VRM model...');
              
              try {
                // Handle VRM data
                if (gltf.userData && gltf.userData.vrm) {
                  this.currentVRM = gltf.userData.vrm;
                  this.scene.add(this.currentVRM.scene);
                  
                  // Initialize animation handler
                  this.initAnimationHandler();
                  
                  this.updateStatus('VRM model loaded successfully!', 'success');
                } else {
                  // Fallback to just using the GLTF scene
                  this.updateStatus('No VRM data found, using raw GLTF scene', 'warning');
                  
                  this.currentVRM = {
                    scene: gltf.scene,
                    update: null
                  };
                  this.scene.add(gltf.scene);
                  
                  // Initialize animation handler
                  this.initAnimationHandler();
                }
                
                // Update UI
                this.updateAnimationControls();
              } catch (error) {
                console.error('Error processing VRM model:', error);
                this.showError(`Error processing VRM model: ${error.message}`);
              }
            },
            (error) => {
              console.error('Error parsing file:', error);
              this.showError(`Failed to parse VRM file: ${error.message}`);
            }
          );
        };
        
        reader.onerror = (error) => {
          console.error('Error reading file:', error);
          this.showError('Failed to read file');
        };
        
        // Read the file as an array buffer
        reader.readAsArrayBuffer(file);
      }
      
      initAnimationHandler() {
        if (!this.currentVRM) return null;
        
        try {
          // Create animation handler
          this.animationHandler = new VRMAnimationHandler(
            { currentVRM: this.currentVRM },
            this.updateStatus.bind(this),
            this.showError.bind(this)
          );
          
          // Create and set fallback animation
          const idleAnimation = this.animationHandler.createIdleAnimation();
          if (idleAnimation) {
            this.animationHandler.setFallbackAnimation(idleAnimation);
            this.animationHandler.playAnimation(idleAnimation);
          }
          
          return this.animationHandler;
        } catch (error) {
          console.error('Error initializing animation handler:', error);
          this.showError(`Failed to initialize animation handler: ${error.message}`);
          return null;
        }
      }
      
      loadAnimationFromFile(file) {
        if (!this.currentVRM) {
          this.updateStatus('Please load a VRM model first', 'error');
          return;
        }
        
        if (!this.animationHandler) {
          this.initAnimationHandler();
          
          if (!this.animationHandler) {
            this.showError('Failed to initialize animation handler');
            return;
          }
        }
        
        this.updateStatus(`Loading animation from file: ${file.name}...`);
        
        this.animationHandler.loadAnimationFromFile(file)
          .then((animations) => {
            if (animations && animations.length > 0) {
              this.updateStatus(`Animation loaded successfully: ${file.name}`, 'success');
              this.updateAnimationList(animations);
            } else {
              this.updateStatus(`No animations found in ${file.name}`, 'warning');
            }
            this.updateAnimationControls();
          })
          .catch((error) => {
            console.error('Error loading animation:', error);
            this.showError(`Failed to load animation: ${error.message}`);
            this.updateAnimationControls();
          });
      }
      
      updateAnimationList(animations) {
        if (!animations || animations.length === 0) {
          this.animationListElement.innerHTML = '<div class="animation-item">No animations loaded</div>';
          return;
        }
        
        this.animationListElement.innerHTML = '';
        
        animations.forEach((animation, index) => {
          const item = document.createElement('div');
          item.className = 'animation-item';
          if (index === 0) item.className += ' active';
          
          item.textContent = animation.name || `Animation ${index + 1}`;
          
          item.addEventListener('click', () => {
            // Remove active class from all items
            const items = this.animationListElement.querySelectorAll('.animation-item');
            items.forEach(i => i.classList.remove('active'));
            
            // Add active class to clicked item
            item.classList.add('active');
            
            // Play the selected animation
            this.animationHandler.playAnimation(animation);
            this.updateStatus(`Playing animation: ${animation.name || `Animation ${index + 1}`}`);
            this.playAnimationButton.textContent = 'Pause';
          });
          
          this.animationListElement.appendChild(item);
        });
      }
      
      updateAnimationControls() {
        const vrmLoaded = !!this.currentVRM;
        const animationActive = this.animationHandler && this.animationHandler.currentAction;
        
        // Update file input
        this.animationFileInput.disabled = !vrmLoaded;
        
        // Update drop zone
        this.animationDropZone.style.opacity = vrmLoaded ? '1' : '0.5';
        this.animationDropZone.style.cursor = vrmLoaded ? 'pointer' : 'not-allowed';
        this.animationDropZone.textContent = vrmLoaded 
          ? 'Drag & Drop Animation File Here' 
          : 'Load a VRM model first';
        
        // Update buttons
        this.playAnimationButton.disabled = !animationActive;
        this.playAnimationButton.textContent = animationActive && 
          animationActive.isRunning() && 
          !animationActive.paused ? 'Pause' : 'Play';
        
        this.stopAnimationButton.disabled = !animationActive;
        this.resetAnimationButton.disabled = !animationActive;
      }
      
      updateStatus(message, type = 'info') {
        if (!this.statusElement) return;
        
        this.statusElement.textContent = message;
        
        // Remove all status classes
        this.statusElement.classList.remove('success', 'error', 'warning', 'info');
        
        // Add the appropriate class
        this.statusElement.classList.add(type);
      }
      
      showError(message) {
        if (!this.errorElement) return;
        
        this.errorElement.textContent = message;
        this.errorElement.style.display = 'block';
      }
      
      clearError() {
        if (!this.errorElement) return;
        
        this.errorElement.textContent = '';
        this.errorElement.style.display = 'none';
      }
    }
    
    // Initialize the app when the DOM is loaded
    document.addEventListener('DOMContentLoaded', () => {
      window.app = new VRMAnimationApp();
    });
  </script>
</body>
</html> 