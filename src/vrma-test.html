<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VRMA Animation Test</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f0f0f0;
      color: #333;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }
    
    h1 {
      text-align: center;
      margin-bottom: 20px;
    }
    
    .viewer-container {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
    }
    
    .vrm-viewer {
      flex: 1;
      min-width: 300px;
      height: 500px;
      background-color: #222;
      border-radius: 8px;
      overflow: hidden;
      position: relative;
    }
    
    .controls-container {
      flex: 1;
      min-width: 300px;
      background-color: #fff;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
    
    .status-container {
      margin-top: 20px;
      padding: 10px;
      background-color: #eee;
      border-radius: 4px;
    }
    
    .error-container {
      margin-top: 10px;
      padding: 10px;
      background-color: #ffebee;
      color: #c62828;
      border-radius: 4px;
      display: none;
    }
    
    .success {
      color: #2e7d32;
    }
    
    .error {
      color: #c62828;
    }
    
    .warning {
      color: #f57f17;
    }
    
    .info {
      color: #1565c0;
    }
    
    button {
      background-color: #4CAF50;
      color: white;
      border: none;
      padding: 10px 15px;
      margin: 5px 0;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    
    button:hover {
      background-color: #45a049;
    }
    
    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    
    .button-group {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }
    
    .file-input-container {
      margin-bottom: 15px;
    }
    
    .file-input-container label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }
    
    .drop-zone {
      border: 2px dashed #ccc;
      border-radius: 5px;
      padding: 25px;
      text-align: center;
      margin: 15px 0;
      background-color: #f9f9f9;
      cursor: pointer;
      transition: all 0.3s;
    }
    
    .drop-zone:hover {
      background-color: #f0f0f0;
      border-color: #aaa;
    }
    
    pre {
      background-color: #f5f5f5;
      padding: 10px;
      border-radius: 4px;
      overflow: auto;
      font-size: 12px;
      max-height: 200px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>VRMA Animation Test</h1>
    
    <div class="viewer-container">
      <div id="vrm-viewer" class="vrm-viewer"></div>
      
      <div class="controls-container">
        <h2>Controls</h2>
        
        <div class="button-group">
          <button id="load-sample-vrm">Load Sample VRM</button>
          <button id="load-custom-vrm">Load Custom VRM</button>
          <input type="file" id="vrm-file-input" accept=".vrm" style="display: none;">
        </div>
        
        <div id="animation-controls">
          <h3>Animation Controls</h3>
          
          <div class="file-input-container">
            <label for="animation-file-input">Load Animation:</label>
            <input type="file" id="animation-file-input" accept=".vrma,.fbx,.bvh,.gltf,.glb" disabled>
          </div>
          
          <div id="animation-drop-zone" class="drop-zone">
            Drag & Drop Animation File Here
          </div>
          
          <div class="button-group">
            <button id="play-animation" disabled>Play</button>
            <button id="pause-animation" disabled>Pause</button>
            <button id="stop-animation" disabled>Stop</button>
            <button id="test-animation">Test Animation</button>
            <button id="create-vrma">Create Test VRMA</button>
          </div>
          
          <h3>Debug Info</h3>
          <pre id="debug-info">No animation loaded</pre>
        </div>
        
        <div id="status-container" class="status-container">
          Ready to load VRM model
        </div>
        
        <div id="error-container" class="error-container"></div>
      </div>
    </div>
  </div>
  
  <!-- Import Three.js from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.151.3/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.151.3/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.151.3/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.151.3/examples/js/loaders/FBXLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.151.3/examples/js/loaders/BVHLoader.js"></script>
  
  <!-- Import @pixiv/three-vrm from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@1.0.9/lib/three-vrm.min.js"></script>
  
  <!-- Import @pixiv/three-vrm-animation from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/@pixiv/three-vrm-animation@3.3.7/lib/three-vrm-animation.min.js"></script>
  
  <!-- Import Three.js GLTFExporter -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.151.3/examples/js/exporters/GLTFExporter.js"></script>
  
  <!-- Import our local scripts -->
  <script src="js/vrm-animation-handler.js"></script>
  <script src="js/create-test-vrma.js"></script>
  
  <script>
    // Debug VRMAnimation availability
    console.log('VRMAnimation script loaded, checking availability...');
    
    // Make sure VRMAnimation is available globally
    if (typeof VRMAnimation === 'undefined' && window.THREE && window.THREE.VRM) {
      console.log('VRMAnimation not found in global scope, trying to find it in THREE.VRM');
      window.VRMAnimation = {};
      
      // Try to find VRMAnimation in the loaded scripts
      const scripts = document.querySelectorAll('script');
      for (const script of scripts) {
        if (script.src && script.src.includes('three-vrm-animation')) {
          console.log('Found VRMAnimation script:', script.src);
          // The script is loaded, but we need to wait for it to execute
          setTimeout(() => {
            // Check various possible locations
            if (window.THREE.VRMAnimation) {
              window.VRMAnimation = window.THREE.VRMAnimation;
              console.log('Found VRMAnimation in THREE.VRMAnimation, exports:', Object.keys(window.VRMAnimation));
            } else if (window.THREE.VRM && window.THREE.VRM.VRMAnimation) {
              window.VRMAnimation = window.THREE.VRM.VRMAnimation;
              console.log('Found VRMAnimation in THREE.VRM.VRMAnimation, exports:', Object.keys(window.VRMAnimation));
            } else {
              console.error('Could not find VRMAnimation in any expected location');
            }
          }, 500);
          break;
        }
      }
    } else if (typeof VRMAnimation !== 'undefined') {
      console.log('VRMAnimation found in global scope, exports:', Object.keys(VRMAnimation));
    }
    
    // Main application
    class VRMATestApp {
      constructor() {
        // Elements
        this.vrmViewerElement = document.getElementById('vrm-viewer');
        this.statusElement = document.getElementById('status-container');
        this.errorElement = document.getElementById('error-container');
        this.debugInfoElement = document.getElementById('debug-info');
        
        // Buttons
        this.loadSampleVRMButton = document.getElementById('load-sample-vrm');
        this.loadCustomVRMButton = document.getElementById('load-custom-vrm');
        this.vrmFileInput = document.getElementById('vrm-file-input');
        this.animationFileInput = document.getElementById('animation-file-input');
        this.animationDropZone = document.getElementById('animation-drop-zone');
        this.playAnimationButton = document.getElementById('play-animation');
        this.pauseAnimationButton = document.getElementById('pause-animation');
        this.stopAnimationButton = document.getElementById('stop-animation');
        this.testAnimationButton = document.getElementById('test-animation');
        this.createVrmaButton = document.getElementById('create-vrma');
        
        // Three.js components
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.controls = null;
        this.clock = null;
        
        // VRM components
        this.currentVRM = null;
        this.animationHandler = null;
        
        // Initialize
        this.init();
      }
      
      init() {
        this.initScene();
        this.initEventListeners();
        this.animate();
        
        this.updateStatus('Scene initialized, ready to load VRM model');
      }
      
      initScene() {
        // Create scene
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x212121);
        
        // Create camera
        this.camera = new THREE.PerspectiveCamera(
          30.0,
          this.vrmViewerElement.clientWidth / this.vrmViewerElement.clientHeight,
          0.1,
          20.0
        );
        this.camera.position.set(0.0, 1.0, 5.0);
        
        // Create renderer
        this.renderer = new THREE.WebGLRenderer({
          antialias: true,
          alpha: true
        });
        this.renderer.setSize(this.vrmViewerElement.clientWidth, this.vrmViewerElement.clientHeight);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        this.vrmViewerElement.appendChild(this.renderer.domElement);
        
        // Create camera controls
        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
        this.controls.target.set(0.0, 1.0, 0.0);
        this.controls.update();
        
        // Add lights
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(1.0, 1.0, 1.0).normalize();
        directionalLight.castShadow = true;
        this.scene.add(directionalLight);
        
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        this.scene.add(ambientLight);
        
        // Add grid helper
        const gridHelper = new THREE.GridHelper(10, 10, 0x555555, 0x333333);
        this.scene.add(gridHelper);
        
        // Create clock
        this.clock = new THREE.Clock();
        this.clock.start();
        
        // Handle window resize
        window.addEventListener('resize', this.onWindowResize.bind(this));
      }
      
      initEventListeners() {
        // Load sample VRM
        this.loadSampleVRMButton.addEventListener('click', () => {
          this.loadSampleVRM();
        });
        
        // Load custom VRM
        this.loadCustomVRMButton.addEventListener('click', () => {
          this.vrmFileInput.click();
        });
        
        // Handle VRM file selection
        this.vrmFileInput.addEventListener('change', (e) => {
          const file = e.target.files[0];
          if (file) {
            this.loadVRMFromFile(file);
          }
        });
        
        // Handle animation file selection
        this.animationFileInput.addEventListener('change', (e) => {
          const file = e.target.files[0];
          if (file) {
            this.loadAnimationFromFile(file);
          }
        });
        
        // Animation drop zone events
        this.animationDropZone.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.stopPropagation();
          
          if (!this.currentVRM) return;
          
          this.animationDropZone.style.backgroundColor = 'rgba(200, 200, 255, 0.2)';
          this.animationDropZone.style.borderColor = '#aaa';
        });
        
        this.animationDropZone.addEventListener('dragleave', (e) => {
          e.preventDefault();
          e.stopPropagation();
          
          this.animationDropZone.style.backgroundColor = '#f9f9f9';
          this.animationDropZone.style.borderColor = '#ccc';
        });
        
        this.animationDropZone.addEventListener('drop', (e) => {
          e.preventDefault();
          e.stopPropagation();
          
          this.animationDropZone.style.backgroundColor = '#f9f9f9';
          this.animationDropZone.style.borderColor = '#ccc';
          
          if (!this.currentVRM) {
            this.updateStatus('Please load a VRM model first', 'error');
            return;
          }
          
          const file = e.dataTransfer.files[0];
          if (file) {
            this.loadAnimationFromFile(file);
          }
        });
        
        // Animation control buttons
        this.playAnimationButton.addEventListener('click', () => {
          if (this.animationHandler && this.animationHandler.currentAction) {
            this.animationHandler.currentAction.paused = false;
            this.animationHandler.currentAction.play();
            this.updateStatus('Animation playing');
            this.updateAnimationControls();
          }
        });
        
        this.pauseAnimationButton.addEventListener('click', () => {
          if (this.animationHandler && this.animationHandler.currentAction) {
            this.animationHandler.currentAction.paused = true;
            this.updateStatus('Animation paused');
            this.updateAnimationControls();
          }
        });
        
        this.stopAnimationButton.addEventListener('click', () => {
          if (this.animationHandler) {
            this.animationHandler.stopAnimation();
            this.updateStatus('Animation stopped');
            this.updateAnimationControls();
          }
        });
        
        // Test animation button
        this.testAnimationButton.addEventListener('click', () => {
          if (!this.currentVRM) {
            this.updateStatus('Please load a VRM model first', 'error');
            return;
          }
          
          if (!this.animationHandler) {
            this.initAnimationHandler();
          }
          
          if (this.animationHandler) {
            this.updateStatus('Creating test animation...', 'info');
            
            // Create a simple test animation
            const testAnimation = this.animationHandler.createSimpleTestAnimation();
            
            if (testAnimation) {
              // Play the test animation
              this.animationHandler.playAnimation(testAnimation);
              this.updateStatus('Test animation created and playing', 'success');
              this.updateAnimationControls();
              
              // Update debug info
              this.updateDebugInfo(testAnimation);
            } else {
              this.updateStatus('Failed to create test animation', 'error');
            }
          }
        });
        
        // Click on animation drop zone to trigger file input
        this.animationDropZone.addEventListener('click', () => {
          if (this.currentVRM) {
            this.animationFileInput.click();
          }
        });
        
        // Create VRMA button
        if (this.createVrmaButton) {
          this.createVrmaButton.addEventListener('click', () => {
            if (typeof window.createAndDownloadTestVRMA === 'function') {
              this.updateStatus('Creating and downloading test VRMA file...', 'info');
              window.createAndDownloadTestVRMA()
                .then(() => {
                  this.updateStatus('Test VRMA file created and downloaded', 'success');
                })
                .catch((error) => {
                  console.error('Error creating VRMA file:', error);
                  this.updateStatus('Failed to create VRMA file', 'error');
                  this.showError(`Error: ${error.message}`);
                });
            } else {
              this.updateStatus('VRMA creation function not available', 'error');
              this.showError('The createAndDownloadTestVRMA function is not available. Make sure the create-test-vrma.js script is loaded.');
            }
          });
        }
      }
      
      animate() {
        requestAnimationFrame(this.animate.bind(this));
        
        const delta = this.clock.getDelta();
        
        // Update VRM
        if (this.currentVRM && this.currentVRM.update) {
          this.currentVRM.update(delta);
        }
        
        // Update animation
        if (this.animationHandler) {
          this.animationHandler.update(delta);
        }
        
        // Update controls
        if (this.controls) {
          this.controls.update();
        }
        
        // Render
        if (this.renderer && this.scene && this.camera) {
          this.renderer.render(this.scene, this.camera);
        }
      }
      
      onWindowResize() {
        if (!this.camera || !this.renderer) return;
        
        this.camera.aspect = this.vrmViewerElement.clientWidth / this.vrmViewerElement.clientHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(this.vrmViewerElement.clientWidth, this.vrmViewerElement.clientHeight);
      }
      
      loadSampleVRM() {
        this.updateStatus('Loading sample VRM model...');
        this.clearError();
        
        // Sample VRM URL from @pixiv/three-vrm examples
        const sampleVRMUrl = 'https://cdn.jsdelivr.net/gh/pixiv/three-vrm@release/packages/three-vrm/examples/models/VRM1_Constraint_Twist_Sample.vrm';
        
        this.loadVRMFromURL(sampleVRMUrl);
      }
      
      loadVRMFromURL(url) {
        // Clear existing model
        if (this.currentVRM && this.currentVRM.scene) {
          this.scene.remove(this.currentVRM.scene);
          this.currentVRM = null;
        }
        
        // Clean up animation handler
        if (this.animationHandler) {
          this.animationHandler.dispose();
          this.animationHandler = null;
        }
        
        this.updateStatus(`Loading VRM from URL: ${url}...`);
        
        // Create loader
        const loader = new THREE.GLTFLoader();
        
        // Register VRM plugin
        loader.register((parser) => {
          return new THREE.VRM.VRMLoaderPlugin(parser);
        });
        
        // Load the model
        loader.load(
          url,
          (gltf) => {
            this.updateStatus('Processing VRM model...');
            
            try {
              // Handle VRM data
              if (gltf.userData && gltf.userData.vrm) {
                this.currentVRM = gltf.userData.vrm;
                this.scene.add(this.currentVRM.scene);
                
                // Initialize animation handler
                this.initAnimationHandler();
                
                this.updateStatus('VRM model loaded successfully!', 'success');
              } else {
                // Fallback to just using the GLTF scene
                this.updateStatus('No VRM data found, using raw GLTF scene', 'warning');
                
                this.currentVRM = {
                  scene: gltf.scene,
                  update: null
                };
                this.scene.add(gltf.scene);
                
                // Initialize animation handler
                this.initAnimationHandler();
              }
              
              // Update UI
              this.updateAnimationControls();
            } catch (error) {
              console.error('Error processing VRM model:', error);
              this.showError(`Error processing VRM model: ${error.message}`);
            }
          },
          (progress) => {
            const percent = progress.total > 0 ? Math.round(progress.loaded / progress.total * 100) : 0;
            this.updateStatus(`Loading model: ${percent}%`);
          },
          (error) => {
            console.error('Error loading VRM model:', error);
            this.showError(`Failed to load VRM model: ${error.message}`);
          }
        );
      }
      
      loadVRMFromFile(file) {
        if (!file) return;
        
        // Clear existing model
        if (this.currentVRM && this.currentVRM.scene) {
          this.scene.remove(this.currentVRM.scene);
          this.currentVRM = null;
        }
        
        // Clean up animation handler
        if (this.animationHandler) {
          this.animationHandler.dispose();
          this.animationHandler = null;
        }
        
        this.updateStatus(`Loading VRM from file: ${file.name}...`);
        this.clearError();
        
        // Create file reader
        const reader = new FileReader();
        
        reader.onload = (e) => {
          // Create loader
          const loader = new THREE.GLTFLoader();
          
          // Register VRM plugin
          loader.register((parser) => {
            return new THREE.VRM.VRMLoaderPlugin(parser);
          });
          
          // Parse the loaded file
          loader.parse(
            e.target.result,
            '',
            (gltf) => {
              this.updateStatus('Processing VRM model...');
              
              try {
                // Handle VRM data
                if (gltf.userData && gltf.userData.vrm) {
                  this.currentVRM = gltf.userData.vrm;
                  this.scene.add(this.currentVRM.scene);
                  
                  // Initialize animation handler
                  this.initAnimationHandler();
                  
                  this.updateStatus('VRM model loaded successfully!', 'success');
                } else {
                  // Fallback to just using the GLTF scene
                  this.updateStatus('No VRM data found, using raw GLTF scene', 'warning');
                  
                  this.currentVRM = {
                    scene: gltf.scene,
                    update: null
                  };
                  this.scene.add(gltf.scene);
                  
                  // Initialize animation handler
                  this.initAnimationHandler();
                }
                
                // Update UI
                this.updateAnimationControls();
              } catch (error) {
                console.error('Error processing VRM model:', error);
                this.showError(`Error processing VRM model: ${error.message}`);
              }
            },
            (error) => {
              console.error('Error parsing file:', error);
              this.showError(`Failed to parse VRM file: ${error.message}`);
            }
          );
        };
        
        reader.onerror = (error) => {
          console.error('Error reading file:', error);
          this.showError('Failed to read file');
        };
        
        // Read the file as an array buffer
        reader.readAsArrayBuffer(file);
      }
      
      initAnimationHandler() {
        if (!this.currentVRM) return null;
        
        try {
          // Create animation handler
          this.animationHandler = new VRMAnimationHandler(
            { currentVRM: this.currentVRM },
            this.updateStatus.bind(this),
            this.showError.bind(this)
          );
          
          // Initialize the mixer
          this.animationHandler.initMixer();
          
          // Create and set fallback animation
          const idleAnimation = this.animationHandler.createIdleAnimation();
          if (idleAnimation) {
            this.animationHandler.setFallbackAnimation(idleAnimation);
            this.animationHandler.playAnimation(idleAnimation);
            
            // Update debug info
            this.updateDebugInfo(idleAnimation);
          }
          
          return this.animationHandler;
        } catch (error) {
          console.error('Error initializing animation handler:', error);
          this.showError(`Failed to initialize animation handler: ${error.message}`);
          return null;
        }
      }
      
      loadAnimationFromFile(file) {
        if (!this.currentVRM) {
          this.updateStatus('Please load a VRM model first', 'error');
          return;
        }
        
        if (!this.animationHandler) {
          this.initAnimationHandler();
          
          if (!this.animationHandler) {
            this.showError('Failed to initialize animation handler');
            return;
          }
        }
        
        this.updateStatus(`Loading animation from file: ${file.name}...`);
        
        // Check if it's a VRMA file
        const isVRMA = file.name.toLowerCase().endsWith('.vrma');
        
        // For VRMA files, check if VRMAnimation is available
        if (isVRMA) {
          // Check for VRMAnimation in various possible locations
          const VRMAnimationClass = window.VRMAnimation || 
                                   (window.THREE && window.THREE.VRM && window.THREE.VRM.VRMAnimation) ||
                                   (window.THREE && window.THREE.VRMAnimation);
          
          if (!VRMAnimationClass) {
            this.updateStatus('VRMAnimation library not available, cannot load VRMA file', 'error');
            console.error('VRMAnimation not found in:', {
              'window.VRMAnimation': window.VRMAnimation,
              'window.THREE.VRM.VRMAnimation': window.THREE && window.THREE.VRM && window.THREE.VRM.VRMAnimation,
              'window.THREE.VRMAnimation': window.THREE && window.THREE.VRMAnimation
            });
            return;
          } else {
            console.log('Found VRMAnimation class:', VRMAnimationClass);
          }
        }
        
        this.animationHandler.loadAnimationFromFile(file)
          .then((animations) => {
            if (animations && animations.length > 0) {
              this.updateStatus(`Animation loaded successfully: ${file.name}`, 'success');
              
              // Update debug info
              this.updateDebugInfo(animations[0]);
            } else {
              this.updateStatus(`No animations found in ${file.name}`, 'warning');
            }
            this.updateAnimationControls();
          })
          .catch((error) => {
            console.error('Error loading animation:', error);
            this.showError(`Failed to load animation: ${error.message}`);
            this.updateAnimationControls();
          });
      }
      
      updateAnimationControls() {
        const vrmLoaded = !!this.currentVRM;
        const animationActive = this.animationHandler && this.animationHandler.currentAction;
        
        // Update file input
        this.animationFileInput.disabled = !vrmLoaded;
        
        // Update drop zone
        this.animationDropZone.style.opacity = vrmLoaded ? '1' : '0.5';
        this.animationDropZone.style.cursor = vrmLoaded ? 'pointer' : 'not-allowed';
        this.animationDropZone.textContent = vrmLoaded 
          ? 'Drag & Drop Animation File Here' 
          : 'Load a VRM model first';
        
        // Update buttons
        this.playAnimationButton.disabled = !animationActive;
        this.pauseAnimationButton.disabled = !animationActive;
        this.stopAnimationButton.disabled = !animationActive;
      }
      
      updateDebugInfo(animation) {
        if (!animation) {
          this.debugInfoElement.textContent = 'No animation loaded';
          return;
        }
        
        let debugInfo = `Animation: ${animation.name || 'Unnamed'}\n`;
        debugInfo += `Duration: ${animation.duration.toFixed(2)}s\n`;
        debugInfo += `Tracks: ${animation.tracks.length}\n\n`;
        
        if (animation.tracks.length > 0) {
          debugInfo += 'Sample tracks:\n';
          const maxTracks = Math.min(3, animation.tracks.length);
          
          for (let i = 0; i < maxTracks; i++) {
            const track = animation.tracks[i];
            debugInfo += `- ${track.name}: ${track.values.length} values\n`;
          }
        }
        
        this.debugInfoElement.textContent = debugInfo;
      }
      
      updateStatus(message, type = 'info') {
        if (!this.statusElement) return;
        
        this.statusElement.textContent = message;
        
        // Remove all status classes
        this.statusElement.classList.remove('success', 'error', 'warning', 'info');
        
        // Add the appropriate class
        this.statusElement.classList.add(type);
      }
      
      showError(message) {
        if (!this.errorElement) return;
        
        this.errorElement.textContent = message;
        this.errorElement.style.display = 'block';
      }
      
      clearError() {
        if (!this.errorElement) return;
        
        this.errorElement.textContent = '';
        this.errorElement.style.display = 'none';
      }
    }
    
    // Initialize the app when the DOM is loaded
    document.addEventListener('DOMContentLoaded', () => {
      window.app = new VRMATestApp();
    });
  </script>
</body>
</html> 